## 轻松将jmp esp方式 改写为jmp ebx方式

- 写这篇文章，希望能给想我一样的初学缓冲区溢出的菜鸟一些帮助，因为到现在的确还没找到介绍这类的文章。首先，介绍在堆栈溢出中，我们的两种利用方式—jmp esp和jmp ebx；接下来，说明了其转化的简单方法；最后给了两个实际例子，将isno写的.printer利用代码和flashsky写的RPC利用代码改写成jmp ebx的方式，以实现对win2000 sp0-sp4全版本的统一！！
										
- 小知识：关于jmp esp和jmp ebx。在溢出中，我们是通过构造过长的数据，覆盖系统中原来的东西，然后想办法跳到我们自己想执行的程序中去。这里的说的跳转办法最经典的就是jmp esp和jmp ebx这两种---在某个地方，覆盖系统原来的东西为jmp esp或jmp ebx的地址，这样就可以跳到我们想执行的程序中去了。当然，我们想执行的程序，也是我们自己写的，通常就称为ShellCode。跳转的原理，请看下的分析。

#### 一、利用JMP ESP的方式
- 其利用格式是NNNNNNRSSSSS，这里N=NOP，R=RET（jmp esp的地址），S=ShellCode。就是把缓冲区一直覆盖成NOP（空指令，什么都不做），直到原来的EIP位置时，我们填入系统中某个核心dll中的jmp esp的地址，紧跟后面才是我们的ShellCode。
这种方式为什么会执行到ShellCode呢？正常情况下，函数返回时，执行RET指令，这等于POP EIP，会把保存的原来程序的EIP的值恢复，从而完成中断的返回。但在这里，我们把保存的EIP的值覆盖了，改写成了jmp esp的地址。这样，POP  EIP后，EIP = jmp esp的地址，而堆栈指针ESP会往下走，指向ShellCode的开始。程序继续执行，此时EIP里的内容是jmp esp，系统执行jmp esp，就正好就跳到我们的ShellCode的地方了。
- 小知识：push和pop。堆栈是一数据结构，遵循“先进后出，后进先出”的规则，就像我们平时叠盘子一样，先放在下面的最后才能取出来，最后放上去的最先取出来。而在操作系统中，存和取的动作就是push和pop。Push放一个数据到堆栈中去，Pop取一个堆栈中的数据出来。
如果ShellCode是开个端口，那我们就可以远程连上去；如果ShellCode是下载执行，那我们就可以让目标机在网页上下个文件并执行……只要你想到达的功能，都可以想办法实现。ShellCode的写法以后有机会再讨论，在这里，还是看看我们关心的地方，

#### 二、利用JMP EBX的方式
- 其利用格式是NNNNN JESSSSSS。这里N = NOP, J = Jmp 04，E = jmp ebx的地址，S = ShellCode。
这里的J和E的位置是关键，E是在出错处理的入口位置，而J在其前面。
- 在第一种方式中，我们知道将返回地址覆盖成另一个地址。但如果是个无效的地址呢？那里指向的数据或许不能读，或许不能执行，那会怎么样呢？其实相信大家都遇到过，那就是系统会弹出个对话框报错，我们点定，就会终止运行。
这是因为作为一个系统级的程序，内部有健全的出错处理机制。简单的说，如果运行时有错误产生，windows就会跳到一个专门处理错误的地方，对应不同的错误，执行不同的代码。上面执行的代码就是弹出个对话框报错。
所以这里我们故意把返回的地址覆盖成一个错误的地址。这样出错时，windows就会跳到处理错误的入口，而ebx指向入口前4个字节的地方！那我们把错误入口处覆盖为jmp ebx的地址，就会跳到前4个字节，怎么跳到ShellCode呢？在这里我们写入jmp 04，哈哈，往后跳4个字节，正好跳过覆盖值，达到我们的ShellCode！

#### 三、JMP ESP方式转换为JMP EBX方式
- 1、为什么要考虑把JMP ESP方式转换为JMP EBX方式呢？
其实最大的好处是，JMP ESP在各个系统，各个补丁版本上是不一样的，这样就会造成不同的系统不通用；而JMP EBX有一个NT/ 2000/XP/2003所有版本的通用地址！so cool ！ShellCode可以想办法写成为通用的版本，这样只要漏洞本身的入口地址相对位置一样，就可以实现真正的通用啦！！可以想象，这是件多么愉快的事情！
然而在实际中，有许多的expoit，利用的却是JMP ESP方式，比如说isno写的.printer漏洞exploit，和flashsky写的RPC远程溢出exploit，这会导致问题，特别是对RPC来说，如果地址错误，就会导致RPC服务的崩溃，从而不能变换地址作再一次的攻击，要等到对方重启后，才能再试。这样就算是知道对方是2000系统，运气不好，都可能要试5次后才能成功（sp0 – sp4）….
.而如果有了通用的版本，就可以保证无论对方是什么系统，都可以一次成功！
- 2、如何把JMP ESP方式转换为JMP EBX方式呢？
牛人们用的方法，比较直观和清晰，当然技术含量也就比较高。他们一般是用工具attach有问题的服务，反汇编，跟踪进去。找到有问题的点，然后向上找到该服务的异常处理入口。直接分析出异常处理入口位置距离溢出点的长度，从而可以完成JMP ESP和JMP EBX两种方式的利用。
这种方法，对我们菜鸟来说，还是比较困难。无论是跟踪，还是计算长度，都需要比较深厚的经验和技术，没有什么技巧可言，都是实力的表现。
那就没有稍微简单点的方法可以利用了吗？
答案是NO!
- 笔者经过亲自试验，发现了个比较简单的方法（相对于直接分析服务），把已有的jmp esp方式，改进为jmp ebx方式。其思路是，先利用jmp esp的攻击程序，在jmp esp代码后，跟上“\xeb\xfe”，这句即jmp –1。实行模拟攻击后，在被攻击机上调出softice，就会发现停在“\xeb\xfe”这句。这时，我们查看其fs:0000的值，它里面存的就是异常处理的入口地址！这时，我们计算那个值离现在的距离，就轻松知道要填充多少达到异常处理入口了。
小知识：SoftICE：动态分析中最重要的是调试器，分为用户模式和内核模式两种类型。用户模式是指用来调试用户模式的应用程序，它们工作在Ring 3级，如Visual C++等编译器自带的调试器。内核模式调试器指能调试操作系统内核的调试器，它们处于CPU和操作系统之间，工作在Ring 0 级，如SofrICE。SoftICE是Compuwar NuMega公司的产品。是目前公认的最好的系统级调试工具！兼容性和稳定性极好，可在源代码级调试各种应用程序和设备驱动程序，也可使用RCP/IP连接进行远程调试。

#### 下面给两个实际的改写例子来讲解。
##### 四、.printer和RPC exploit的实际
<pre>
1、.printer漏洞的exploit改写
.printer漏洞比较老了，是win2000 sp0和sp1的IIS服务器所具有的漏洞。改写它主要是想讲明方法。
先调出isno写的jmp esp方式的exploit（参看附带源代码）。分析后，知道其漏洞利用是
GET http://AA…..AAAAAESSSSSSSSSS/null.printer?x HTTP/1.0
					 | …268个A… |
即填充268个A后，达到返回地址处。把它覆盖成E = jmp esp的地址，就可以跳到我们的shellcode里面执行了。
如何改写呢？
	就是用我们的思路！
    在E=jmp esp后面添上几句“\xeb\xfe”，然后攻击我们的模拟机，并在模拟机上打开softice，哈哈，看到停在了0172f3e0处，“0172f3e0  EBFE  JMP 0172f3e0”，跟在后面的是我们原来的ShellCode。这样，我们就进入了内部了。
快找异常入口地址，D fs:00，看到得到fs:0里面放的是0x0172f428，哈哈，这就是这里的异常入口地址。如果我们把返回地址的值写成AAAA等非法值，就会产生错误，ebx会变为0x0172f428, 而系统会跳到0x0172f42c执行处理代码，。如果我们把0x0172f42c覆盖成jmp ebx，而把0x0172f428覆盖成nop nop jmp 04，就会跳过覆盖地址，执行跟在jmp ebx后面的shellcode！
试试！异常入口地址是0x0172f428，而现在jmp esp的地址是0x0172f428，相减为80，我们就在isno的代码基础上，多填充80字节，再依次写入jmp04， jmp ebx和shellcode，还是在shellcode前先加上jmp –1，执行，哈哈，果然还是被中断了！证明我们的shellcode被执行啦！而且是jmp ebx形式的哦！(参看改写后的源码)

2、RPC 漏洞的exploit改写
来个更实用的！说到RPC，无人不知了吧。Flashsky最先分析和给出了exploit，冲击波病毒也是利用flashsky的基本代码。但他们都是利用jmp esp地址，所以造成不通用。对系统上表示就是xp系统会停止RPC服务，报错一分钟后重启。
那我们现在改为jmp ebx形式，就可以全盘通用啦！
改的方法和.printer完全一样，但要注意win2000 sp0 sp1 sp2和 sp3 sp4异常入口点和返回点的距离相差了8，为此我们只要用jmp04 jmpebx jmp04 jmpebx多覆盖一次就可以了；而对于xp，相差为6，这样2000和xp不能用完全同一个程序，可以写一个专针对2000所有版本的，再写一个专门针xp和2003的，也可以达到比较通用。具体的改写参看附带的源程序和改写后的代码，希望大家能有所收获，以后能自己将一些攻击程序改写成通用的版本！
<pre>
